---
title: 进程间通信--消息队列
date: 2018-08-04 08:26:30
tags: 进程间通信
category: 进程间通信
---

如何创建一个消息队列?

```php
// 创建消息队列
//在php中通过这两句话就可以创建一个消息队列。 ftok 函数，是可以将一个路径转换成 消息队列 可用的key值。 msg_get_queue函数的第一个参数 是消息队列的key，第二个参数是消息队列的读写权限，这个权限跟文件类似。这个很重要，设置
$msg_key = ftok(__FILE__, 'a');
$msg_queue = msg_get_queue($msg_key, 0666);

// 获取消息队列的状态
$message_queue_status = msg_stat_queue($msg_queue);

// 向消息队列中写
msg_send($msg_queue, 1, 'sui sui sui lucky !');

// 从消息队列中
msg_receive($msg_queue, 0, $message_type, 1024, $message, TRUE, MSG_IPC_NOWAIT);

echo $message . PHP_EOL;

```

　msg_send函数，向指定消息队列写入信息。原型为   bool msg_send ( resource $queue , int $msgtype , mixed $message [, bool $serialize = true [, bool $blocking = true [, int &$errorcode ]]] )， 参数比较多

　　第1个参数 ： resource $queue 表示要写入的消息队列资源。

　　第2个参数 ： int $msgtype 表示写入消息队列的 消息类型，这个参数是 配合 msg_receive读取消息队列函数 使用的，下面会说。

　　第3个参数 ：   mixed $message 你要发送的信息，最大为 65536 个字节。

    第4个参数 ：  bool $serialize = true 为可选项，是否序列化你发送的消息。

　　第5个参数 ： bool $blocking = true 是否阻塞，当你发送的消息很大，而此时的消息队列无法存入的时候，此时消息队列就会阻塞，除非等到有别的进程从消息队列中读取了别的消息，然后消息队列有足够的空间存储你要发送的信息，才能继续执行。你可以设置这个参数为false，

　　这样你发送信息就会失败，此时错误信息会在 第6个参数 $errorcode中体现，错误码为 MSG_EAGAIN ，你可以根据这个错误码，重新发送你的消息。

　　第6个参数 ： int &$errorcode 记录写入中出现的一系列错误。


 msg_receive 。

 原型为：bool msg_receive ( resource $queue , int $desiredmsgtype , int &$msgtype , int $maxsize , mixed &$message [, bool $unserialize = true [, int $flags = 0 [, int &$errorcode ]]] )

　　第1个参数：resource $queue 表示要读取的消息队列资源。

　　第2个参数 ：int $desiredmsgtype 读取的消息类型。这个参数为 0 的时候，你可以读取 msg_send 以任意 消息类型 发送的消息。 如果此参数和你发送的某个消息类型相同，比如你有 2个消息，一个是通过 1类型发送的，一个是通过2 类型发送的。你用 0 可以接收这两种消息

　　而你用 1 只能接收到 以1类型发送的消息。

　　第3个参数 ： int &$msgtype 你读取到的信息，它发送时的消息类型会存储在该参数中。

　　第4个参数 ： int $maxsize 你以多大的字节去读取消息，如果这个值小于你要读取的内容的长度，你会读取失败。

　　第5个参数 ：mixed &$message 读取的内容。

　　第6个参数 ： bool $unserialize = true 内容是否序列化

　　第7个参数 ：int $flags = 0 读取标识。除了默认的0 之外，还有3个参数可选 MSG_IPC_NOWAIT 这个参数表示如果没有从消息队列中读取到信息，会立马返回，并返回错误码 MSG_ENOMSG. 

　　MSG_EXCEPT 这个参数 是配合 第2个参数使用的，如果使用这个参数，你读取到的第一个参数，不是你第一个发送的参数。(队列先进先出)

　　MSG_NOERROR 如果读取的内容过大，而你指定的第4个参数又不够的时候，它会截断这个消息，并且不报错。

　　

　　销毁消息队列的方法 ： msg_remove_queue($msg_queue); 


父子进程之间实现通信:

```php
//父子进程通过消息队列通信

//创建消息队列
$msg_key = ftok(__FILE__, 'a');
$msg_queue = msg_get_queue($msg_key, 0666);

//启动进程
$pid = pcntl_fork();

if ($pid == 0) {
	//子进程向父进程报告
	msg_send($msg_queue, 1, "father i am " . getmypid() . " and i am working! \n");
	exit(); //退出子进程
} else if ($pid) {

	msg_receive($msg_queue, 0, $message_type, 1024, $message, TRUE, MSG_IPC_NOWAIT);
	echo $message;
	pcntl_wait($status); //阻塞回收子进程
	var_dump($status);

	msg_remove_queue($msg_queue);

}

```
