---
title: 进程间通信--有名管道
date: 2018-08-04 07:16:09
tags: 进程间通信
category: 进程间通信
---

# 管道PIPE

　管道用于承载简称之间的通讯数据。为了方便理解，可以将管道比作文件，进程A将数据写到管道P中，然后进程B从管道P中读取数据。php提供的管道操作API与操作文件的API基本一样，除了创建管道使用posix_mkfifo函数，读写等操作均与文件操作函数相同。当然，你可以直接使用文件模拟管道，但是那样无法使用管道的特性了。

# 例子一

　通过管道通信的大概思路是，首先创建一个管道，然后子进程向管道中写入信息，父进程从管道中读取信息，这样就可以做到父子进程直接实现通信了。

```php

//php进程间通信--有名管道

$pipePath = '/home/test.pipe';
if(!file_exists($pipePath))
{
	if(!posix_mkfifo($pipePath, 0666))
	{
		exit('make piple false'.PHP_EOL);
	}
}

// 创建进程,子进程写管道,父进程读管道
$pid = pcntl_fork();
if($pid == 0)
{
	$file = fopen($pipePath, 'w');
	fwrite($file, 'sui');
	sleep(10);
	exit;
}else{
	//父进程得到子进程的pid,读管道
	$file = fopen($pipePath, 'r');
	//如果 mode 为0，资源流将会被转换为非阻塞模式；如果是1，资源流将会被转换为阻塞模式。
	// stream_set_blocking( $file, 0 );  //设置成读取非阻塞
	echo fread( $file, 20 ) . PHP_EOL;

    pcntl_wait($status);  //回收子进程
}
```

# 例子二

```php
 //创建管道
$pipePath = '/home/test.pipe';

 if( !file_exists( $pipePath ) ){
     if( !posix_mkfifo( $pipePath, 0666 ) ){
         exit("make pipe fail \n");
     }
 }

 // 创建2个子进程写文件
 for ($i=0; $i < 2; $i++) 
 { 
 	$pid = pcntl_fork();
 	if($pid == 0)
 	{
 	       file_put_contents('./pipe.log', $i . " write pipe\n", FILE_APPEND );

 	       $file = fopen( $pipePath, 'w' );
	        fwrite( $file, $i . "\n" );  //向管道中写标识，标识写入完毕。
	        fclose( $file );
	        exit();  //退出子进程
 	}
 }

// 父进程要做的事情
 // 1.读取管道中的写出状态,判断是否完全写完
 // 2.拷贝写好的文件
 // 3.删除管道
 // 4.回收进程
 
 $file = fopen($pipePath, 'r');
 $line = 0;
 while (1) 
 {
 	$end = fread($file, 1024);
 	 foreach( str_split( $end ) as $c) 
 	 {
 	 		  if ( "\n" == $c ) 
 	 		  {
            		 $line++;
        	  }
 	 }

 	 if($line == 2)
 	 {
 	 	 copy( './pipe.log', './pipe_copy.log' );
         fclose( $file );
         unlink( $pipePath );
         pcntl_wait( $status );
         exit("ok \n");
 	 }
 }
```