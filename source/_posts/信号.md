---
title: 进程间通信 - 信号
date: 2018-08-03 23:17:36
tags: 进程间通信
category: 进程间通信
---

软中断信号（signal，又简称为信号）用来通知进程发生了异步事件。在软件层次上是对中断机制的一种模拟，在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。信号是进程间通信机制中唯一的异步通信机制，一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。进程之间可以互相通过系统调用kill发送软中断信号。内核也可以因为内部事件而给进程发送信号，通知进程发生了某个事件。信号机制除了基本通知功能外，还可以传递附加信息。

```
You should see all signals and their codes in your system using: kill -l
In my Debian GNU/Linux 7.6 (wheezy):

1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM
16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR
31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
63) SIGRTMAX-1  64) SIGRTMAX
```

## 例子

启动3个子进程，运行，父进程等待5秒钟，向子进程发送sigint信号。子进程捕获信号，调用信号处理函数处理。(SIGINT ctrl+c 终止信号)

```php
<?php 
$parentPid = posix_getpid();
// $pid = getmypid();
// echo "{$pid}".PHP_EOL;
echo "父进程为pid:{$parentPid}\n";

// 定义一个信号处理函数
function signalHandler($sig)
{
	if($sig == SIGINT)
	{
		$pid = getmygid();
		exit("{$pid}进程wo被小主人终止了ooooo");
	}
}

/*PHP < 5.3 使用
配合pcntl_signal使用,表示每执行一条低级指令，就检查一次信号，如果检测到注册的信号，就调用其信号处理器。
declare(ticks=1);
*/
pcntl_signal(SIGINT, 'signalHandler'); //注册信号处理函数
$childList = [];

for ($i=0; $i < 3; $i++) 
{ 
	 $pid = pcntl_fork();
	 if($pid == 0)
	 {
	 	// 子进程里
	 	while (true) {
	 		 //PHP >= 5.3
             //调用已安装的信号处理器
             //必须在循环里调用，为了检测是否有新的信号等待dispatching。
              pcntl_signal_dispatch();

               echo "i am child " . getmypid() . " 正在 running ! \n";
               $sec = rand(10,12);
               sleep($sec);
               exit;
	 	}
	 }else if( $pid == -1 ){
         exit("fork fail!" . PHP_EOL);
     }else{
     	// 父进程
         $childList[$pid] = 1;
         // 等待子进程退出
         pcntl_wait($status);
     }
}

sleep(5);
echo 'ssssssssssssssssssssssssss';

foreach( $childList as $key=>$vo )
{
     posix_kill( $key, SIGINT );  //触发SIGINIT信号
}

echo  "($parentPid)parent exit " . PHP_EOL;

 ?>
```
